<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>愤怒的小鸟：最终版</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Luckiest+Guy&display=swap');
        
        body { 
            margin: 0; padding: 0; overflow: hidden; 
            background: linear-gradient(to bottom, #87CEEB 0%, #E0F7FA 100%); /* 渐变蓝天 */
            font-family: 'Luckiest Guy', cursive;
            touch-action: none; /* 阻止手机浏览器默认滚动 */
            user-select: none; /* 阻止文本选择 */
        }

        #canvas-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 1; /* 确保Canvas在UI之下 */
        }

        /* UI 覆盖层 */
        .ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: space-between;
            pointer-events: none; /* 默认不拦截鼠标事件 */
            z-index: 2; /* 确保UI在Canvas之上 */
        }

        .hud {
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 28px;
            color: #fff;
            text-shadow: 3px 3px 0 #333;
            background: rgba(0,0,0,0.2);
        }
        .hud-left { display: flex; align-items: center; }
        .hud-right { font-size: 18px; opacity: 0.9; }

        /* 弹窗样式 */
        .modal {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            pointer-events: auto; /* 允许点击 */
            z-index: 3; /* 确保在最上层 */
            display: none; /* 默认隐藏 */
        }

        .modal-content {
            background: linear-gradient(to bottom, #ffeb3b 0%, #fbc02d 100%);
            padding: 40px 60px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            border: 6px solid #ffcc00;
            max-width: 90%; /* 手机适配 */
        }

        .modal h1 { margin: 0 0 15px 0; color: #d32f2f; font-size: 60px; text-shadow: 3px 3px 0 #fff;}
        .modal p { font-size: 24px; color: #333; margin-bottom: 25px; }

        button {
            background: #4CAF50; /* 绿色 */
            border: none;
            padding: 15px 40px;
            font-size: 26px;
            color: white;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 7px 0 #2E7D32;
            font-family: 'Luckiest Guy', cursive;
            transition: transform 0.1s ease-out, box-shadow 0.1s ease-out;
            margin: 10px;
            min-width: 180px;
        }
        
        button:active { transform: translateY(4px); box-shadow: 0 3px 0 #2E7D32; }
        button.next-level { background: #1976D2; box-shadow: 0 7px 0 #1565C0; }
        button.restart { background: #D32F2F; box-shadow: 0 7px 0 #B71C1C; }

        /* 飘分效果 */
        .floating-text {
            position: absolute;
            font-size: 36px;
            color: yellow;
            text-shadow: -2px -2px 0 #000, 2px -2px 0 #000, -2px 2px 0 #000, 2px 2px 0 #000;
            opacity: 0;
            animation: floatUp 1.5s ease-out forwards;
            pointer-events: none;
            z-index: 10;
            font-family: 'Luckiest Guy', cursive;
        }

        @keyframes floatUp {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-80px) scale(1.2); opacity: 0; }
        }

        /* 关卡指示器 */
        .level-indicator {
            width: 20px; height: 20px;
            background: rgba(255,255,255,0.4);
            border-radius: 50%;
            margin: 0 5px;
            border: 2px solid rgba(0,0,0,0.2);
        }
        .level-indicator.active {
            background: #ffcc00;
            border-color: #d32f2f;
        }

    </style>
</head>
<body>

    <div id="canvas-container"></div>

    <div class="ui-layer">
        <div class="hud">
            <div class="hud-left">
                <span>分数: <span id="scoreVal">0</span></span>
                <div style="display:flex; margin-left: 20px;" id="levelIndicators">
                    </div>
            </div>
            <div class="hud-right">按 'R' 重置关卡</div>
        </div>
    </div>

    <div id="startScreen" class="modal">
        <div class="modal-content">
            <h1>ANGRY BIRDS<br><span style="font-size:0.6em; color:#4CAF50;">最终版</span></h1>
            <p>拖拽小鸟，击败所有猪猪！</p>
            <button onclick="startGame()">开始游戏</button>
        </div>
    </div>

    <div id="endModal" class="modal">
        <div class="modal-content">
            <h1 id="endTitle">游戏结束!</h1>
            <p>你的得分: <span id="finalScore">0</span></p>
            <div style="display:flex; justify-content: center;">
                <button class="next-level" onclick="nextLevel()" id="nextLevelBtn">下一关</button>
                <button class="restart" onclick="resetGame()">重新开始</button>
            </div>
        </div>
    </div>

    <script>
        const Engine = Matter.Engine,
              Render = Matter.Render,
              Runner = Matter.Runner,
              Bodies = Matter.Bodies,
              Composite = Matter.Composite,
              Events = Matter.Events,
              Mouse = Matter.Mouse,
              MouseConstraint = Matter.MouseConstraint,
              Constraint = Matter.Constraint,
              Vector = Matter.Vector;

        let engine, render, runner;
        let bird, sling, firingAnchor;
        let score = 0;
        let currentLevel = 0;
        let gameActive = false;
        let floatingTextElements = [];

        const levels = [
            // 关卡 0: 基础关卡
            (w, h) => {
                const platformX = w * 0.75;
                const platformY = h - 150;
                return [
                    Bodies.rectangle(platformX, platformY, 200, 20, { isStatic: true, label: 'Platform', render: { fillStyle: '#A0522D' } }),
                    Bodies.rectangle(platformX - 30, platformY - 25, 40, 40, { label: 'Box', render: { fillStyle: '#deb887' } }),
                    Bodies.rectangle(platformX + 30, platformY - 25, 40, 40, { label: 'Box', render: { fillStyle: '#deb887' } }),
                    Bodies.circle(platformX, platformY - 65, 20, { label: 'Pig', render: { fillStyle: '#76c893' } })
                ];
            },
            // 关卡 1: 堆叠关卡
            (w, h) => {
                const platformX = w * 0.75;
                const platformY = h - 150;
                return [
                    Bodies.rectangle(platformX, platformY, 250, 20, { isStatic: true, label: 'Platform', render: { fillStyle: '#A0522D' } }),
                    Bodies.rectangle(platformX - 40, platformY - 25, 40, 40, { label: 'Box', render: { fillStyle: '#deb887' } }),
                    Bodies.rectangle(platformX + 40, platformY - 25, 40, 40, { label: 'Box', render: { fillStyle: '#deb887' } }),
                    Bodies.rectangle(platformX, platformY - 65, 40, 40, { label: 'Box', render: { fillStyle: '#deb887' } }),
                    Bodies.circle(platformX - 20, platformY - 105, 20, { label: 'Pig', render: { fillStyle: '#76c893' } }),
                    Bodies.circle(platformX + 20, platformY - 105, 20, { label: 'Pig', render: { fillStyle: '#76c893' } })
                ];
            },
            // 关卡 2: 高难度关卡
            (w, h) => {
                const platformX = w * 0.75;
                const platformY = h - 150;
                return [
                    Bodies.rectangle(platformX, platformY, 300, 20, { isStatic: true, label: 'Platform', render: { fillStyle: '#A0522D' } }),
                    Bodies.rectangle(platformX - 80, platformY - 25, 40, 40, { label: 'Box', render: { fillStyle: '#deb887' } }),
                    Bodies.rectangle(platformX, platformY - 25, 40, 40, { label: 'Box', render: { fillStyle: '#deb887' } }),
                    Bodies.rectangle(platformX + 80, platformY - 25, 40, 40, { label: 'Box', render: { fillStyle: '#deb887' } }),
                    Bodies.circle(platformX - 40, platformY - 65, 20, { label: 'Pig', render: { fillStyle: '#76c893' } }),
                    Bodies.circle(platformX + 40, platformY - 65, 20, { label: 'Pig', render: { fillStyle: '#76c893' } }),
                    Bodies.rectangle(platformX, platformY - 105, 40, 40, { label: 'Box', render: { fillStyle: '#deb887' } }),
                    Bodies.circle(platformX, platformY - 145, 20, { label: 'Pig', render: { fillStyle: '#76c893' } })
                ];
            }
        ];

        function initEngineAndRender() {
            const container = document.getElementById('canvas-container');
            container.innerHTML = ''; 

            engine = Engine.create();
            engine.gravity.y = 1; // 调整重力

            const width = window.innerWidth;
            const height = window.innerHeight;

            render = Render.create({
                element: container,
                engine: engine,
                options: {
                    width: width,
                    height: height,
                    wireframes: false,
                    background: 'transparent',
                    pixelRatio: window.devicePixelRatio || 1
                }
            });

            // 地面
            const ground = Bodies.rectangle(width/2, height + 30, width, 100, { 
                isStatic: true, label: 'Ground',
                render: { fillStyle: '#4a7526' } // 深绿色地面
            });
            Composite.add(engine.world, ground);

            // 鼠标控制 (修复拖拽问题)
            const mouse = Mouse.create(render.canvas);
            const mouseConstraint = MouseConstraint.create(engine, {
                mouse: mouse,
                constraint: {
                    stiffness: 0.2, // 更软的弹弓，方便拖拽
                    render: { visible: false }
                }
            });
            Composite.add(engine.world, mouseConstraint);
            render.mouse = mouse;

            // 确保不影响Matter.js本身的拖拽
            Events.on(mouseConstraint, 'startdrag', function(event) {
                if (event.body === bird && !bird.isFired) {
                    // 只允许拖拽鸟
                } else {
                    mouseConstraint.body = null; // 阻止拖拽其他物体
                }
            });

            Events.on(mouseConstraint, 'enddrag', function(event) {
                if (event.body === bird && !bird.isFired) {
                    const dist = Vector.magnitude(Vector.sub(bird.position, firingAnchor));
                    if (dist > 20) { // 只有拉开足够距离才发射
                        fireBird();
                    } else { // 没拉开就放回去
                        Matter.Body.setPosition(bird, firingAnchor);
                        Matter.Body.setVelocity(bird, {x:0, y:0});
                        Matter.Body.setAngularVelocity(bird, 0);
                        sling = Constraint.create({
                            pointA: firingAnchor, bodyB: bird, stiffness: 0.05, length: 1, render: { visible: false }
                        });
                        Composite.add(engine.world, sling);
                    }
                }
            });

            Render.run(render);
            runner = Runner.create();
            Runner.run(runner, engine);

            // 物理渲染后的自定义绘制
            Events.on(render, 'afterRender', customRender);
            Events.on(engine, 'collisionStart', handleCollisions);
        }

        function loadLevel(levelIndex) {
            // 清理旧物体 (除了地面)
            const bodiesToRemove = Composite.allBodies(engine.world).filter(body => body.label !== 'Ground' && body.label !== 'Bird');
            Composite.remove(engine.world, bodiesToRemove);
            
            // 重置小鸟位置
            if (bird) {
                Matter.Body.setPosition(bird, firingAnchor);
                Matter.Body.setVelocity(bird, {x:0, y:0});
                Matter.Body.setAngularVelocity(bird, 0);
                bird.isFired = false;
                if (!sling) { // 如果弹弓没了就重新创建
                    sling = Constraint.create({
                        pointA: firingAnchor, bodyB: bird, stiffness: 0.05, length: 1, render: { visible: false }
                    });
                    Composite.add(engine.world, sling);
                }
            } else { // 第一次加载游戏时创建小鸟
                const width = window.innerWidth;
                const height = window.innerHeight;
                firingAnchor = { x: width * 0.2, y: height - 180 };
                bird = Bodies.circle(firingAnchor.x, firingAnchor.y, 25, { 
                    label: 'Bird', density: 0.005, restitution: 0.7, friction: 0.1,
                    render: { fillStyle: '#e63946' } // 红色保底
                });
                sling = Constraint.create({
                    pointA: firingAnchor, bodyB: bird, stiffness: 0.05, length: 1, render: { visible: false }
                });
                Composite.add(engine.world, [bird, sling]);
            }

            // 加载当前关卡物体
            const newBodies = levels[levelIndex](window.innerWidth, window.innerHeight);
            Composite.add(engine.world, newBodies);

            updateLevelIndicators();
            gameActive = true;
        }

        function fireBird() {
            if (!bird || bird.isFired) return;
            
            bird.isFired = true;
            Composite.remove(engine.world, sling);
            sling = null;

            // 稍微延迟一下检查胜利条件，让物体有时间稳定
            setTimeout(checkWinCondition, 3000);
        }

        function handleCollisions(event) {
            const pairs = event.pairs;
            pairs.forEach(pair => {
                const bodyA = pair.bodyA;
                const bodyB = pair.bodyB;

                const bodiesInvolved = [bodyA, bodyB];
                let pigHit = false;

                for (const body of bodiesInvolved) {
                    if (body.label === 'Pig' && !body.isDead) {
                        const otherBody = body === bodyA ? bodyB : bodyA;
                        // 确保是撞击而不是静止接触
                        if (otherBody.speed > 5 || body.speed > 5) { 
                            body.isDead = true; // 标记猪已死亡
                            addScore(1000, body.position);
                            Composite.remove(engine.world, body); // 移除猪
                            pigHit = true;
                        }
                    } else if (body.label === 'Box') {
                        if (body.speed > 8) {
                            addScore(100, body.position);
                        }
                    }
                }
                if (pigHit) checkWinCondition();
            });
        }

        function addScore(points, position) {
            score += points;
            document.getElementById('scoreVal').innerText = score;

            // 创建飘字元素
            const floatingText = document.createElement('div');
            floatingText.className = 'floating-text';
            floatingText.innerText = `+${points}`;
            floatingText.style.left = `${position.x}px`;
            floatingText.style.top = `${position.y}px`;
            document.body.appendChild(floatingText);
            
            // 记录并清理
            floatingTextElements.push(floatingText);
            setTimeout(() => {
                if(floatingText.parentNode) floatingText.parentNode.removeChild(floatingText);
                floatingTextElements = floatingTextElements.filter(el => el !== floatingText);
            }, 1500); // 配合 CSS 动画时间
        }

        function checkWinCondition() {
            if (!gameActive) return;

            const pigsLeft = engine.world.bodies.filter(b => b.label === 'Pig');
            if (pigsLeft.length === 0) {
                // 胜利
                gameActive = false;
                document.getElementById('endTitle').innerText = "太棒了!";
                document.getElementById('finalScore').innerText = score;
                document.getElementById('nextLevelBtn').style.display = (currentLevel < levels.length - 1) ? 'inline-block' : 'none';
                document.getElementById('endModal').style.display = 'flex';
            } else if (bird && bird.isFired && Vector.magnitude(bird.velocity) < 0.5) {
                // 小鸟静止且还有猪
                gameActive = false;
                document.getElementById('endTitle').innerText = "挑战失败!";
                document.getElementById('finalScore').innerText = score;
                document.getElementById('nextLevelBtn').style.display = 'none'; // 失败不能进下一关
                document.getElementById('endModal').style.display = 'flex';
            } else if (!bird || bird.position.y > window.innerHeight + 100 || bird.position.x < -100 || bird.position.x > window.innerWidth + 100) {
                 // 鸟掉出去了
                gameActive = false;
                document.getElementById('endTitle').innerText = "挑战失败!";
                document.getElementById('finalScore').innerText = score;
                document.getElementById('nextLevelBtn').style.display = 'none';
                document.getElementById('endModal').style.display = 'flex';
            } else {
                // 游戏还在进行，或等待物理稳定
                setTimeout(checkWinCondition, 1000); 
            }
        }

        // --- 游戏流程控制 ---
        function startGame() {
            document.getElementById('startScreen').style.display = 'none';
            initEngineAndRender();
            score = 0;
            currentLevel = 0;
            document.getElementById('scoreVal').innerText = score;
            loadLevel(currentLevel);
        }

        function nextLevel() {
            currentLevel++;
            document.getElementById('endModal').style.display = 'none';
            if (currentLevel < levels.length) {
                loadLevel(currentLevel);
            } else {
                // 所有关卡都通关了
                document.getElementById('endTitle').innerText = "恭喜你，通关所有关卡!";
                document.getElementById('nextLevelBtn').style.display = 'none';
                document.getElementById('endModal').style.display = 'flex';
            }
        }

        function resetGame() {
            document.getElementById('endModal').style.display = 'none';
            if(render) {
                Render.stop(render);
                Runner.stop(runner);
            }
            // 清理飘字
            floatingTextElements.forEach(el => el.parentNode && el.parentNode.removeChild(el));
            floatingTextElements = [];

            // 重新开始游戏
            startGame();
        }

        function updateLevelIndicators() {
            const container = document.getElementById('levelIndicators');
            container.innerHTML = '';
            for(let i = 0; i < levels.length; i++) {
                const dot = document.createElement('div');
                dot.className = 'level-indicator' + (i === currentLevel ? ' active' : '');
                container.appendChild(dot);
            }
        }

        // --- 自定义渲染 (美化物体) ---
        function customRender() {
            const ctx = render.context;
            const bodies = Composite.allBodies(engine.world);

            // 绘制天空和地面的额外细节 (如果需要)
            drawClouds(ctx);
            drawGrass(ctx, window.innerHeight);

            // 绘制弹弓皮筋 (在鸟后面)
            if (sling && bird) {
                ctx.beginPath();
                ctx.moveTo(firingAnchor.x - 10, firingAnchor.y + 10); // 左叉点
                ctx.lineTo(bird.position.x, bird.position.y);
                ctx.lineWidth = 6;
                ctx.strokeStyle = '#3d2e1e';
                ctx.lineCap = 'round';
                ctx.stroke();
            }

            // 绘制所有物体
            bodies.forEach(body => {
                ctx.save();
                ctx.translate(body.position.x, body.position.y);
                ctx.rotate(body.angle);

                if (body.label === 'Bird') {
                    drawFancyBird(ctx, 25);
                } else if (body.label === 'Pig') {
                    drawFancyPig(ctx, 20);
                } else if (body.label === 'Box' || body.label === 'Platform') {
                    drawWoodenBox(ctx, body);
                }
                // Ground已经在底部绘制了
                
                ctx.restore();
            });

            // 绘制弹弓前半部分 (遮挡鸟)
            drawSlingshotFront(ctx, firingAnchor);
        }

        // --- 绘制函数 ---
        function drawFancyBird(ctx, radius) {
            // 身体
            ctx.beginPath(); ctx.arc(0, 0, radius, 0, Math.PI * 2); ctx.fillStyle = '#d90429'; ctx.fill();
            // 眼睛
            ctx.beginPath(); ctx.arc(radius * 0.4, -radius * 0.4, radius * 0.35, 0, Math.PI * 2); ctx.fillStyle = 'white'; ctx.fill();
            ctx.beginPath(); ctx.arc(-radius * 0.4, -radius * 0.4, radius * 0.35, 0, Math.PI * 2); ctx.fillStyle = 'white'; ctx.fill();
            // 瞳孔
            ctx.beginPath(); ctx.arc(radius * 0.4 + 2, -radius * 0.4 + 2, radius * 0.1, 0, Math.PI * 2); ctx.fillStyle = 'black'; ctx.fill();
            ctx.beginPath(); ctx.arc(-radius * 0.4 + 2, -radius * 0.4 + 2, radius * 0.1, 0, Math.PI * 2); ctx.fillStyle = 'black'; ctx.fill();
            // 眉毛
            ctx.beginPath(); ctx.rect(-radius * 0.6, -radius * 0.8, radius * 1.2, radius * 0.2); ctx.fillStyle = 'black'; ctx.fill();
            // 嘴巴
            ctx.beginPath(); ctx.moveTo(0, radius * 0.3); ctx.lineTo(radius * 0.6, radius * 0.6); ctx.lineTo(0, radius); ctx.closePath(); ctx.fillStyle = '#ffcc00'; ctx.fill();
            ctx.strokeStyle = '#a0522d'; ctx.lineWidth = 2; ctx.stroke();
        }

        function drawFancyPig(ctx, radius) {
            // 身体
            ctx.beginPath(); ctx.arc(0, 0, radius, 0, Math.PI * 2); ctx.fillStyle = '#76c893'; ctx.fill();
            ctx.strokeStyle = '#4b8c65'; ctx.lineWidth = 2; ctx.stroke();
            // 鼻子
            ctx.beginPath(); ctx.ellipse(0, radius * 0.3, radius * 0.4, radius * 0.3, 0, 0, Math.PI * 2); ctx.fillStyle = '#5fad06'; ctx.fill();
            ctx.beginPath(); ctx.arc(-radius * 0.15, radius * 0.25, radius * 0.08, 0, Math.PI * 2); ctx.fillStyle = 'black'; ctx.fill();
            ctx.beginPath(); ctx.arc(radius * 0.15, radius * 0.25, radius * 0.08, 0, Math.PI * 2); ctx.fillStyle = 'black'; ctx.fill();
            // 眼睛
            ctx.beginPath(); ctx.arc(radius * 0.3, -radius * 0.3, radius * 0.15, 0, Math.PI * 2); ctx.fillStyle = 'white'; ctx.fill();
            ctx.beginPath(); ctx.arc(-radius * 0.3, -radius * 0.3, radius * 0.15, 0, Math.PI * 2); ctx.fillStyle = 'white'; ctx.fill();
            ctx.beginPath(); ctx.arc(radius * 0.3 + 2, -radius * 0.3 + 1, radius * 0.05, 0, Math.PI * 2); ctx.fillStyle = 'black'; ctx.fill();
            ctx.beginPath(); ctx.arc(-radius * 0.3 + 2, -radius * 0.3 + 1, radius * 0.05, 0, Math.PI * 2); ctx.fillStyle = 'black'; ctx.fill();
        }

        function drawWoodenBox(ctx, body) {
            const w = body.bounds.max.x - body.bounds.min.x;
            const h = body.bounds.max.y - body.bounds.min.y;
            ctx.fillStyle = '#deb887';
            ctx.fillRect(-w/2, -h/2, w, h);
            ctx.strokeStyle = '#8b4513';
            ctx.lineWidth = 2;
            ctx.strokeRect(-w/2, -h/2, w, h);
            // 木纹细节
            ctx.beginPath(); ctx.moveTo(-w/2, -h/4); ctx.lineTo(w/2, -h/4); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(-w/2, h/4); ctx.lineTo(w/2, h/4); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(-w/4, -h/2); ctx.lineTo(-w/4, h/2); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(w/4, -h/2); ctx.lineTo(w/4, h/2); ctx.stroke();
        }

        function drawSlingshotFront(ctx, pos) {
            ctx.fillStyle = '#5C4033';
            // 柱子
            ctx.fillRect(pos.x - 5, pos.y + 5, 10, 100);
            // 叉
            ctx.strokeStyle = '#5C4033';
            ctx.lineWidth = 8;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(pos.x, pos.y + 10);
            ctx.lineTo(pos.x - 15, pos.y - 20);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(pos.x, pos.y + 10);
            ctx.lineTo(pos.x + 15, pos.y - 20);
            ctx.stroke();
            
            // 弹弓另一边的皮筋 (遮挡鸟)
            if (sling && bird) {
                ctx.beginPath();
                ctx.moveTo(firingAnchor.x + 10, firingAnchor.y + 10); // 右叉点
                ctx.lineTo(bird.position.x, bird.position.y);
                ctx.lineWidth = 6;
                ctx.strokeStyle = '#3d2e1e';
                ctx.lineCap = 'round';
                ctx.stroke();
            }
        }

        function drawClouds(ctx) {
            ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
            // 第一朵云
            ctx.beginPath();
            ctx.arc(100, 120, 40, 0, Math.PI * 2);
            ctx.arc(150, 100, 50, 0, Math.PI * 2);
            ctx.arc(200, 120, 45, 0, Math.PI * 2);
            ctx.fill();
            // 第二朵云
            ctx.beginPath();
            ctx.arc(window.innerWidth - 250
